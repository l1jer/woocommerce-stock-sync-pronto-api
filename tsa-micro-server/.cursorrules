# TSA Micro-Server Cursor Rules

You are an expert in Node.js, Express.js, PostgreSQL, Redis, Prisma ORM, and Render deployment platform, specialising in building efficient micro-services for free tier cloud platforms.

## Project Context

This is a micro-server project designed for Render free tier deployment that:
- Synchronises product data from Tasco API (5 calls/sec rate limit)
- Provides external API endpoints for stock queries
- Includes an admin dashboard for monitoring and analytics
- Operates within strict resource constraints (512MB RAM, 512MB PostgreSQL, 25MB Redis)

## Key Technologies & Constraints

### Core Stack
- **Runtime**: Node.js 18+ with Express.js
- **Database**: PostgreSQL (512MB) with Prisma ORM
- **Cache**: Redis (25MB) for sessions and caching
- **Frontend**: Server-side rendered EJS templates with Tailwind CSS
- **Authentication**: Express-session with Redis store
- **Package Manager**: yarn (not npm)
- **Deployment**: Render free tier with PM2

### Free Tier Limitations
- Application sleeps after 15 minutes of inactivity
- 30-second cold start time
- Limited connection pool size
- 1GB PostgreSQL storage, 25MB Redis
- 100GB/month bandwidth
- 512MB RAM limit
- Shared CPU resources

## Development Principles

### Performance Optimisation
- Write memory-efficient code due to 512MB RAM limit
- Implement aggressive caching strategies using Redis
- Use connection pooling with Prisma for database efficiency
- Minimise cold start impact with optimised startup procedures
- Implement lazy loading and on-demand resource allocation
- Use streaming for large data operations

### API Integration Best Practices
- Respect Tasco API rate limits (5 calls/sec, conservative approach)
- Implement exponential backoff for retry mechanisms
- Use intelligent scheduling based on business hours:
  - Business hours (8am-5pm): Full sync every 30 minutes
  - Non-business hours: Full sync every 60 minutes
- Cache API responses in Redis with appropriate TTL
- Handle paginated responses efficiently (100 products per call, 200-350 pages)

### Database Design
- Design lean schemas optimised for 512MB PostgreSQL limit
- Use Prisma for type-safe database operations
- Implement proper indexing for query performance
- Use Redis for frequently accessed data and session storage
- Implement data archiving strategies for old records

### Security & Monitoring
- Use Helmet.js for security headers
- Implement proper CORS configuration
- Use Winston for logging with log rotation (disk space limits)
- Create health check endpoints optimised for Render
- Implement Redis-based error tracking and reporting
- Use session-based authentication with Redis store

## Code Style & Structure

### File Organisation
```
/
├── src/
│   ├── config/          # Environment and database configuration
│   ├── controllers/     # Route handlers
│   ├── middleware/      # Custom middleware
│   ├── models/          # Prisma models and database logic
│   ├── services/        # Business logic and API clients
│   ├── utils/           # Helper functions
│   └── views/           # EJS templates
├── prisma/              # Database schema and migrations
├── tests/               # Jest test files
└── public/              # Static assets
```

### Naming Conventions
- Use kebab-case for file names: `api-handler.js`, `stock-updater.js`
- Use camelCase for variables and functions: `stockLevel`, `updateProduct()`
- Use PascalCase for classes and constructors: `TascoApiClient`, `StockUpdater`
- Use UPPER_SNAKE_CASE for constants: `API_RATE_LIMIT`, `SYNC_INTERVAL`

### Error Handling
- Always implement proper error handling with try-catch blocks
- Use Winston for structured logging
- Create custom error classes for different error types
- Implement graceful degradation for non-critical failures
- Log errors to Redis for dashboard monitoring

### TypeScript Usage
- Use TypeScript for type safety where beneficial
- Define interfaces for API responses and database models
- Use Prisma's generated types for database operations
- Implement proper type checking for external API data

## API Development Guidelines

### External Endpoints
- Implement rate limiting using express-rate-limit with Redis store
- Use Redis caching for frequently requested data
- Provide clear API documentation with Swagger/OpenAPI
- Implement proper input validation using Joi
- Return consistent JSON response formats
- Include proper HTTP status codes and error messages

### Dashboard Development
- Use server-side rendering with EJS templates
- Implement responsive design with Tailwind CSS
- Use Chart.js for analytics visualisation
- Minimise client-side JavaScript to reduce complexity
- Implement session-based authentication
- Create efficient data queries to minimise database load

## Testing Strategy

### Unit Testing
- Write Jest tests for core business logic
- Mock external API calls and database operations
- Test error handling and edge cases
- Keep test suite lightweight for CI/CD efficiency

### Integration Testing
- Test database connections and Prisma operations
- Test Redis caching and session management
- Test API endpoints with proper authentication
- Test sync processes with mocked Tasco API responses

## Deployment Considerations

### Render Optimisation
- Configure PM2 for process management
- Set up proper environment variable management
- Implement health checks for Render monitoring
- Optimise startup time to reduce cold start impact
- Configure log retention policies for disk space management

### CI/CD Pipeline
- Use Render's GitHub integration for automatic deployments
- Implement proper build scripts with yarn
- Include database migration steps in deployment
- Set up environment-specific configurations

## Code Quality Standards

### Linting & Formatting
- Use ESLint with Airbnb configuration
- Implement Prettier for consistent code formatting
- Use British/Australian English spelling in code and comments
- Include comprehensive debugging statements and technical comments

### Documentation
- Document all API endpoints with clear examples
- Include inline comments for complex business logic
- Maintain up-to-date README with deployment instructions
- Document environment variables and configuration options

## Language Guidelines
- Use British/Australian English spelling in all code, comments, and documentation
- Write technical comments and documentation in English
- Responses and explanations can be in English or Mandarin Chinese as appropriate
- Include comprehensive debugging logs and error messages

## Best Practices Checklist

### Before Committing Code
- [ ] Code follows memory efficiency guidelines
- [ ] Proper error handling implemented
- [ ] Redis caching strategy applied where appropriate
- [ ] Database queries optimised with proper indexing
- [ ] Rate limiting respected for external API calls
- [ ] Logging implemented with Winston
- [ ] Tests written and passing
- [ ] Documentation updated
- [ ] Environment variables properly configured
- [ ] Security headers and CORS configured

### Performance Monitoring
- Monitor memory usage and optimise accordingly
- Track API response times and database query performance
- Monitor Redis memory usage and implement cleanup strategies
- Track sync job performance and adjust scheduling as needed
- Monitor external API usage to stay within rate limits

Remember: This micro-server must operate efficiently within Render's free tier constraints while providing reliable API synchronisation and external access to stock data. Prioritise performance, reliability, and resource efficiency in all development decisions. 